import express from "express";
import cors from "cors";
import mongoose from "mongoose";
import dotenv from "dotenv";
import bcrypt from 'bcryptjs';
import { fileURLToPath } from 'url';
import { dirname, extname } from 'path';
import multer from 'multer';
import csv from 'csv-parser';
import { Readable } from 'stream';
import jwt from 'jsonwebtoken';
import fs from 'fs';
import path from 'path';
import Admin from "./Admin.js";
import Department from "./Department.js";
import DepartmentHead from "./DepartmentHead.js";
import Class from "./Class.js";
import Teacher from "./Teacher.js";
import Course from "./Course.js";
import Student from "./Student.js";
import Announcement from "./Announcement.js";
import Exam from "./Exam.js";
import Question from "./Question.js";
import Assignment from "./Assignment.js";

// JWT Configuration
const JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key';

// Middleware to verify JWT token
const authenticateToken = (req, res, next) => {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];

  if (!token) {
    return res.status(401).json({ message: 'No token provided', status: 'error' });
  }

  jwt.verify(token, JWT_SECRET, (err, user) => {
    if (err) {
      return res.status(403).json({ message: 'Invalid or expired token', status: 'error' });
    }
    req.user = user;
    next();
  });
};

// Get the directory name for ES modules
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Load environment variables with explicit path
dotenv.config({ path: __dirname + '/.env' });

// Debug: Log the MONGO_URI to see if it's loaded
console.log("MONGO_URI from .env:", process.env.MONGO_URI);
console.log("__dirname:", __dirname);

const app = express();

// Enable CORS for all routes
app.use((req, res, next) => {
  const allowedOrigins = [
    'http://localhost:5173',
    'http://localhost:5174',
    'http://localhost:5175'
  ];
  
  const origin = req.headers.origin;
  if (allowedOrigins.includes(origin)) {
    res.setHeader('Access-Control-Allow-Origin', origin);
  }
  
  res.setHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization');
  res.setHeader('Access-Control-Allow-Credentials', 'true');
  
  // Handle preflight requests
  if (req.method === 'OPTIONS') {
    return res.status(200).end();
  }
  
  next();
});

app.use(express.json());

// Configure multer for file uploads
const upload = multer({
  storage: multer.memoryStorage(),
  limits: {
    fileSize: 10 * 1024 * 1024, // 10MB limit
  },
  fileFilter: (req, file, cb) => {
    if (file.mimetype === 'text/csv' || file.originalname.endsWith('.csv')) {
      cb(null, true);
    } else {
      cb(new Error('Only CSV files are allowed'), false);
    }
  }
});

// Configure multer for assignment file uploads
const assignmentUpload = multer({
  storage: multer.diskStorage({
    destination: (req, file, cb) => {
      const uploadPath = 'uploads/assignments/';
      // Create directory if it doesn't exist
      if (!fs.existsSync(uploadPath)) {
        fs.mkdirSync(uploadPath, { recursive: true });
      }
      cb(null, uploadPath);
    },
    filename: (req, file, cb) => {
      // Generate unique filename
      const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
      cb(null, file.fieldname + '-' + uniqueSuffix + path.extname(file.originalname));
    }
  }),
  limits: {
    fileSize: 10 * 1024 * 1024, // 10MB limit
  },
  fileFilter: (req, file, cb) => {
    // Allow common document types
    if (
      file.mimetype === 'application/pdf' ||
      file.mimetype === 'application/msword' ||
      file.mimetype === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' ||
      file.mimetype === 'application/vnd.ms-powerpoint' ||
      file.mimetype === 'application/vnd.openxmlformats-officedocument.presentationml.presentation' ||
      file.mimetype === 'application/vnd.ms-excel' ||
      file.mimetype === 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' ||
      file.mimetype.startsWith('text/')
    ) {
      cb(null, true);
    } else {
      cb(new Error('Only PDF, Word, PowerPoint, Excel, and text files are allowed'), false);
    }
  }
});

// Connect to MongoDB with better error handling
const connectDB = async () => {
  try {
    if (!process.env.MONGO_URI) {
      throw new Error("MONGO_URI is not defined in environment variables");
    }
    
    console.log("Attempting to connect to MongoDB with URI:", process.env.MONGO_URI);
    
    // Add connection options for better debugging
    const options = {
      serverSelectionTimeoutMS: 5000, // Timeout after 5s instead of 30s
      socketTimeoutMS: 45000, // Close sockets after 45 seconds of inactivity
    };
    
    await mongoose.connect(process.env.MONGO_URI, options);
    console.log("✅ MongoDB connected successfully");
    
    // Add connection event listeners
    mongoose.connection.on('error', err => {
      console.error('MongoDB connection error:', err);
    });
    
    mongoose.connection.on('disconnected', () => {
      console.log('MongoDB disconnected');
    });
  } catch (err) {
    console.error("❌ MongoDB connection error:", err);
    process.exit(1);
  }
};

connectDB();

app.get("/", (req, res) => {
  res.send("Backend is running...");
});

// Add a new API endpoint to demonstrate data exchange
app.get("/api/data", (req, res) => {
  res.json({
    message: "Hello from the backend!",
    timestamp: new Date().toISOString(),
    status: "success"
  });
});

// Add POST endpoint for form submissions with MongoDB integration
app.post("/api/submit", async (req, res) => {
  try {
    // Since we removed the User model, we'll just return a success message
    res.json({
      message: "Data received successfully!",
      data: req.body,
      timestamp: new Date().toISOString(),
      status: "success"
    });
  } catch (error) {
    res.status(500).json({
      message: "Error processing data: " + error.message,
      status: "error"
    });
  }
});

// Get all admins endpoint
app.get("/api/admins", async (req, res) => {
  try {
    const admins = await Admin.find({}, { name: 1, email: 1, createdAt: 1 });
    res.json({
      message: "Admins retrieved successfully!",
      data: admins,
      count: admins.length,
      status: "success"
    });
  } catch (error) {
    res.status(500).json({
      message: "Error retrieving admins: " + error.message,
      status: "error"
    });
  }
});

// Admin login endpoint
app.post("/api/admin/login", async (req, res) => {
  try {
    const { email, password } = req.body;
    
    // Find admin by email
    const admin = await Admin.findOne({ email });
    
    if (!admin) {
      return res.status(401).json({
        message: "Invalid credentials",
        status: "error"
      });
    }
    
    // Check password
    const isPasswordValid = await admin.comparePassword(password);
    
    if (!isPasswordValid) {
      return res.status(401).json({
        message: "Invalid credentials",
        status: "error"
      });
    }
    
    // Generate JWT token
    const token = jwt.sign(
      { 
        id: admin._id, 
        email: admin.email,
        role: 'admin' 
      },
      JWT_SECRET,
      { expiresIn: '1d' }
    );
    
    res.json({
      message: "Login successful!",
      token: token,
      data: {
        id: admin._id,
        name: admin.name,
        email: admin.email,
        role: 'admin'
      },
      status: "success"
    });
  } catch (error) {
    res.status(500).json({
      message: "Error during login: " + error.message,
      status: "error"
    });
  }
});

// Department management endpoints
// Create a new department
app.post("/api/departments", async (req, res) => {
  try {
    const { name, science } = req.body;
    
    // Create a new department in MongoDB
    const department = new Department({ name, science });
    await department.save();
    
    res.status(201).json({
      message: "Department created successfully!",
      data: { 
        id: department._id,
        name: department.name,
        science: department.science
      },
      status: "success"
    });
  } catch (error) {
    if (error.code === 11000) {
      // Duplicate name error
      return res.status(400).json({
        message: "Department with this name already exists",
        status: "error"
      });
    }
    
    res.status(500).json({
      message: "Error creating department: " + error.message,
      status: "error"
    });
  }
});

// Get all departments
app.get("/api/departments", async (req, res) => {
  try {
    const departments = await Department.find({});
    res.json({
      message: "Departments retrieved successfully!",
      data: departments,
      count: departments.length,
      status: "success"
    });
  } catch (error) {
    res.status(500).json({
      message: "Error retrieving departments: " + error.message,
      status: "error"
    });
  }
});

// Get a specific department by ID
app.get("/api/departments/:id", async (req, res) => {
  try {
    const department = await Department.findById(req.params.id);
    
    if (!department) {
      return res.status(404).json({
        message: "Department not found",
        status: "error"
      });
    }
    
    res.json({
      message: "Department retrieved successfully!",
      data: department,
      status: "success"
    });
  } catch (error) {
    res.status(500).json({
      message: "Error retrieving department: " + error.message,
      status: "error"
    });
  }
});

// Update a department by ID
app.put("/api/departments/:id", async (req, res) => {
  try {
    const { name, science } = req.body;
    
    const department = await Department.findByIdAndUpdate(
      req.params.id,
      { name, science },
      { new: true, runValidators: true }
    );
    
    if (!department) {
      return res.status(404).json({
        message: "Department not found",
        status: "error"
      });
    }
    
    res.json({
      message: "Department updated successfully!",
      data: department,
      status: "success"
    });
  } catch (error) {
    if (error.code === 11000) {
      // Duplicate name error
      return res.status(400).json({
        message: "Department with this name already exists",
        status: "error"
      });
    }
    
    res.status(500).json({
      message: "Error updating department: " + error.message,
      status: "error"
    });
  }
});

// Delete a department by ID
app.delete("/api/departments/:id", async (req, res) => {
  try {
    const department = await Department.findByIdAndDelete(req.params.id);
    
    if (!department) {
      return res.status(404).json({
        message: "Department not found",
        status: "error"
      });
    }
    
    res.json({
      message: "Department deleted successfully!",
      data: department,
      status: "success"
    });
  } catch (error) {
    res.status(500).json({
      message: "Error deleting department: " + error.message,
      status: "error"
    });
  }
});

// Department Head management endpoints
// Create a new department head
app.post("/api/department-heads", async (req, res) => {
  try {
    const { name, email, phoneNo, password, department } = req.body;
    
    // Hash the password
    const hashedPassword = await bcrypt.hash(password, 10);
    
    // Create a new department head in MongoDB
    const departmentHead = new DepartmentHead({ name, email, phoneNo, password: hashedPassword, department });
    await departmentHead.save();
    
    res.status(201).json({
      message: "Department head created successfully!",
      data: { 
        id: departmentHead._id,
        name: departmentHead.name,
        email: departmentHead.email,
        phoneNo: departmentHead.phoneNo,
        department: departmentHead.department
      },
      status: "success"
    });
  } catch (error) {
    if (error.code === 11000) {
      // Duplicate email error
      return res.status(400).json({
        message: "Department head with this email already exists",
        status: "error"
      });
    }
    
    res.status(500).json({
      message: "Error creating department head: " + error.message,
      status: "error"
    });
  }
});

// Get all department heads
app.get("/api/department-heads", async (req, res) => {
  try {
    const departmentHeads = await DepartmentHead.find({});
    res.json({
      message: "Department heads retrieved successfully!",
      data: departmentHeads,
      count: departmentHeads.length,
      status: "success"
    });
  } catch (error) {
    res.status(500).json({
      message: "Error retrieving department heads: " + error.message,
      status: "error"
    });
  }
});

// Get a specific department head by ID
app.get("/api/department-heads/:id", async (req, res) => {
  try {
    const departmentHead = await DepartmentHead.findById(req.params.id);
    
    if (!departmentHead) {
      return res.status(404).json({
        message: "Department head not found",
        status: "error"
      });
    }
    
    res.json({
      message: "Department head retrieved successfully!",
      data: departmentHead,
      status: "success"
    });
  } catch (error) {
    res.status(500).json({
      message: "Error retrieving department head: " + error.message,
      status: "error"
    });
  }
});

// Update a department head by ID
app.put("/api/department-heads/:id", async (req, res) => {
  try {
    const { name, email, phoneNo, password, department } = req.body;
    
    if (password) {
      // Hash the password if it exists
      req.body.password = await bcrypt.hash(password, 10);
    }
    
    const departmentHead = await DepartmentHead.findByIdAndUpdate(
      req.params.id,
      { name, email, phoneNo, password, department },
      { new: true, runValidators: true }
    );
    
    if (!departmentHead) {
      return res.status(404).json({
        message: "Department head not found",
        status: "error"
      });
    }
    
    res.json({
      message: "Department head updated successfully!",
      data: departmentHead,
      status: "success"
    });
  } catch (error) {
    if (error.code === 11000) {
      // Duplicate email error
      return res.status(400).json({
        message: "Department head with this email already exists",
        status: "error"
      });
    }
    
    res.status(500).json({
      message: "Error updating department head: " + error.message,
      status: "error"
    });
  }
});

// Delete a department head by ID
app.delete("/api/department-heads/:id", async (req, res) => {
  try {
    const departmentHead = await DepartmentHead.findByIdAndDelete(req.params.id);
    
    if (!departmentHead) {
      return res.status(404).json({
        message: "Department head not found",
        status: "error"
      });
    }
    
    res.json({
      message: "Department head deleted successfully!",
      data: departmentHead,
      status: "success"
    });
  } catch (error) {
    res.status(500).json({
      message: "Error deleting department head: " + error.message,
      status: "error"
    });
  }
});

// Class management endpoints
// Create a new class
app.post("/api/classes", async (req, res) => {
  try {
    const { name, department } = req.body;
    
    // Create a new class in MongoDB
    const newClass = new Class({ name, department });
    await newClass.save();
    
    res.status(201).json({
      message: "Class created successfully!",
      data: { 
        id: newClass._id,
        name: newClass.name,
        department: newClass.department
      },
      status: "success"
    });
  } catch (error) {
    if (error.code === 11000) {
      // Duplicate name error
      return res.status(400).json({
        message: "Class with this name already exists",
        status: "error"
      });
    }
    
    res.status(500).json({
      message: "Error creating class: " + error.message,
      status: "error"
    });
  }
});

// Get all classes
app.get("/api/classes", async (req, res) => {
  try {
    const classes = await Class.find({});
    res.json({
      message: "Classes retrieved successfully!",
      data: classes,
      count: classes.length,
      status: "success"
    });
  } catch (error) {
    res.status(500).json({
      message: "Error retrieving classes: " + error.message,
      status: "error"
    });
  }
});

// Get a specific class by ID
app.get("/api/classes/:id", async (req, res) => {
  try {
    const newClass = await Class.findById(req.params.id);
    
    if (!newClass) {
      return res.status(404).json({
        message: "Class not found",
        status: "error"
      });
    }
    
    res.json({
      message: "Class retrieved successfully!",
      data: newClass,
      status: "success"
    });
  } catch (error) {
    res.status(500).json({
      message: "Error retrieving class: " + error.message,
      status: "error"
    });
  }
});

// Update a class by ID
app.put("/api/classes/:id", async (req, res) => {
  try {
    const { name, department } = req.body;
    
    const newClass = await Class.findByIdAndUpdate(
      req.params.id,
      { name, department },
      { new: true, runValidators: true }
    );
    
    if (!newClass) {
      return res.status(404).json({
        message: "Class not found",
        status: "error"
      });
    }
    
    res.json({
      message: "Class updated successfully!",
      data: newClass,
      status: "success"
    });
  } catch (error) {
    if (error.code === 11000) {
      // Duplicate name error
      return res.status(400).json({
        message: "Class with this name already exists",
        status: "error"
      });
    }
    
    res.status(500).json({
      message: "Error updating class: " + error.message,
      status: "error"
    });
  }
});

// Delete a class by ID
app.delete("/api/classes/:id", async (req, res) => {
  try {
    const newClass = await Class.findByIdAndDelete(req.params.id);
    
    if (!newClass) {
      return res.status(404).json({
        message: "Class not found",
        status: "error"
      });
    }
    
    res.json({
      message: "Class deleted successfully!",
      data: newClass,
      status: "success"
    });
  } catch (error) {
    res.status(500).json({
      message: "Error deleting class: " + error.message,
      status: "error"
    });
  }
});

// Teacher management endpoints
// Create a new teacher
app.post("/api/teachers", async (req, res) => {
  try {
    const { name, email, phoneNo, password, department } = req.body;
    
    // Hash the password
    const hashedPassword = await bcrypt.hash(password, 10);
    
    // Create a new teacher in MongoDB
    const teacher = new Teacher({ name, email, phoneNo, password: hashedPassword, department });
    await teacher.save();
    
    res.status(201).json({
      message: "Teacher created successfully!",
      data: { 
        id: teacher._id,
        name: teacher.name,
        email: teacher.email,
        phoneNo: teacher.phoneNo,
        department: teacher.department
      },
      status: "success"
    });
  } catch (error) {
    if (error.code === 11000) {
      // Duplicate email error
      return res.status(400).json({
        message: "Teacher with this email already exists",
        status: "error"
      });
    }
    
    res.status(500).json({
      message: "Error creating teacher: " + error.message,
      status: "error"
    });
  }
});

// Get all teachers
app.get("/api/teachers", async (req, res) => {
  try {
    const teachers = await Teacher.find({});
    res.json({
      message: "Teachers retrieved successfully!",
      data: teachers,
      count: teachers.length,
      status: "success"
    });
  } catch (error) {
    res.status(500).json({
      message: "Error retrieving teachers: " + error.message,
      status: "error"
    });
  }
});

// Get a specific teacher by ID
app.get("/api/teachers/:id", async (req, res) => {
  try {
    const teacher = await Teacher.findById(req.params.id);
    
    if (!teacher) {
      return res.status(404).json({
        message: "Teacher not found",
        status: "error"
      });
    }
    
    res.json({
      message: "Teacher retrieved successfully!",
      data: teacher,
      status: "success"
    });
  } catch (error) {
    res.status(500).json({
      message: "Error retrieving teacher: " + error.message,
      status: "error"
    });
  }
});

// Update a teacher by ID
app.put("/api/teachers/:id", async (req, res) => {
  try {
    const { name, email, phoneNo, password, department } = req.body;
    
    if (password) {
      // Hash the password if it exists
      req.body.password = await bcrypt.hash(password, 10);
    }
    
    const teacher = await Teacher.findByIdAndUpdate(
      req.params.id,
      { name, email, phoneNo, password, department },
      { new: true, runValidators: true }
    );
    
    if (!teacher) {
      return res.status(404).json({
        message: "Teacher not found",
        status: "error"
      });
    }
    
    res.json({
      message: "Teacher updated successfully!",
      data: teacher,
      status: "success"
    });
  } catch (error) {
    if (error.code === 11000) {
      // Duplicate email error
      return res.status(400).json({
        message: "Teacher with this email already exists",
        status: "error"
      });
    }
    
    res.status(500).json({
      message: "Error updating teacher: " + error.message,
      status: "error"
    });
  }
});

// Delete a teacher by ID
app.delete("/api/teachers/:id", async (req, res) => {
  try {
    const teacher = await Teacher.findByIdAndDelete(req.params.id);
    
    if (!teacher) {
      return res.status(404).json({
        message: "Teacher not found",
        status: "error"
      });
    }
    
    res.json({
      message: "Teacher deleted successfully!",
      data: teacher,
      status: "success"
    });
  } catch (error) {
    res.status(500).json({
      message: "Error deleting teacher: " + error.message,
      status: "error"
    });
  }
});

// Course management endpoints
// Create a new course
app.post("/api/courses", async (req, res) => {
  try {
    const { name, code, department, teacher } = req.body;
    
    // Create a new course in MongoDB
    const course = new Course({ name, code, department, teacher });
    await course.save();
    
    res.status(201).json({
      message: "Course created successfully!",
      data: { 
        id: course._id,
        name: course.name,
        code: course.code,
        department: course.department,
        teacher: course.teacher
      },
      status: "success"
    });
  } catch (error) {
    if (error.code === 11000) {
      // Duplicate code error
      return res.status(400).json({
        message: "Course with this code already exists",
        status: "error"
      });
    }
    
    res.status(500).json({
      message: "Error creating course: " + error.message,
      status: "error"
    });
  }
});

// Get all courses
app.get("/api/courses", async (req, res) => {
  try {
    const courses = await Course.find({});
    res.json({
      message: "Courses retrieved successfully!",
      data: courses,
      count: courses.length,
      status: "success"
    });
  } catch (error) {
    res.status(500).json({
      message: "Error retrieving courses: " + error.message,
      status: "error"
    });
  }
});

// Get a specific course by ID
app.get("/api/courses/:id", async (req, res) => {
  try {
    const course = await Course.findById(req.params.id);
    
    if (!course) {
      return res.status(404).json({
        message: "Course not found",
        status: "error"
      });
    }
    
    res.json({
      message: "Course retrieved successfully!",
      data: course,
      status: "success"
    });
  } catch (error) {
    res.status(500).json({
      message: "Error retrieving course: " + error.message,
      status: "error"
    });
  }
});

// Update a course by ID
app.put("/api/courses/:id", async (req, res) => {
  try {
    const { name, code, department, teacher } = req.body;
    
    const course = await Course.findByIdAndUpdate(
      req.params.id,
      { name, code, department, teacher },
      { new: true, runValidators: true }
    );
    
    if (!course) {
      return res.status(404).json({
        message: "Course not found",
        status: "error"
      });
    }
    
    res.json({
      message: "Course updated successfully!",
      data: course,
      status: "success"
    });
  } catch (error) {
    if (error.code === 11000) {
      // Duplicate code error
      return res.status(400).json({
        message: "Course with this code already exists",
        status: "error"
      });
    }
    
    res.status(500).json({
      message: "Error updating course: " + error.message,
      status: "error"
    });
  }
});

// Delete a course by ID
app.delete("/api/courses/:id", async (req, res) => {
  try {
    const course = await Course.findByIdAndDelete(req.params.id);
    
    if (!course) {
      return res.status(404).json({
        message: "Course not found",
        status: "error"
      });
    }
    
    res.json({
      message: "Course deleted successfully!",
      data: course,
      status: "success"
    });
  } catch (error) {
    res.status(500).json({
      message: "Error deleting course: " + error.message,
      status: "error"
    });
  }
});

// Student management endpoints
// Create a new student
app.post("/api/students", async (req, res) => {
  try {
    const { name, email, phoneNo, password, department } = req.body;
    
    // Hash the password
    const hashedPassword = await bcrypt.hash(password, 10);
    
    // Create a new student in MongoDB
    const student = new Student({ name, email, phoneNo, password: hashedPassword, department });
    await student.save();
    
    res.status(201).json({
      message: "Student created successfully!",
      data: { 
        id: student._id,
        name: student.name,
        email: student.email,
        phoneNo: student.phoneNo,
        department: student.department
      },
      status: "success"
    });
  } catch (error) {
    if (error.code === 11000) {
      // Duplicate email error
      return res.status(400).json({
        message: "Student with this email already exists",
        status: "error"
      });
    }
    
    res.status(500).json({
      message: "Error creating student: " + error.message,
      status: "error"
    });
  }
});

// Get all students
app.get("/api/students", async (req, res) => {
  try {
    const students = await Student.find({});
    res.json({
      message: "Students retrieved successfully!",
      data: students,
      count: students.length,
      status: "success"
    });
  } catch (error) {
    res.status(500).json({
      message: "Error retrieving students: " + error.message,
      status: "error"
    });
  }
});

// Get a specific student by ID
app.get("/api/students/:id", async (req, res) => {
  try {
    const student = await Student.findById(req.params.id);
    
    if (!student) {
      return res.status(404).json({
        message: "Student not found",
        status: "error"
      });
    }
    
    res.json({
      message: "Student retrieved successfully!",
      data: student,
      status: "success"
    });
  } catch (error) {
    res.status(500).json({
      message: "Error retrieving student: " + error.message,
      status: "error"
    });
  }
});

// Update a student by ID
app.put("/api/students/:id", async (req, res) => {
  try {
    const { name, email, phoneNo, password, department } = req.body;
    
    if (password) {
      // Hash the password if it exists
      req.body.password = await bcrypt.hash(password, 10);
    }
    
    const student = await Student.findByIdAndUpdate(
      req.params.id,
      { name, email, phoneNo, password, department },
      { new: true, runValidators: true }
    );
    
    if (!student) {
      return res.status(404).json({
        message: "Student not found",
        status: "error"
      });
    }
    
    res.json({
      message: "Student updated successfully!",
      data: student,
      status: "success"
    });
  } catch (error) {
    if (error.code === 11000) {
      // Duplicate email error
      return res.status(400).json({
        message: "Student with this email already exists",
        status: "error"
      });
    }
    
    res.status(500).json({
      message: "Error updating student: " + error.message,
      status: "error"
    });
  }
});

// Delete a student by ID
app.delete("/api/students/:id", async (req, res) => {
  try {
    const student = await Student.findByIdAndDelete(req.params.id);
    
    if (!student) {
      return res.status(404).json({
        message: "Student not found",
        status: "error"
      });
    }
    
    res.json({
      message: "Student deleted successfully!",
      data: student,
      status: "success"
    });
  } catch (error) {
    res.status(500).json({
      message: "Error deleting student: " + error.message,
      status: "error"
    });
  }
});

// Announcement management endpoints
// Create a new announcement
app.post("/api/announcements", async (req, res) => {
  try {
    const { title, content, department } = req.body;
    
    // Create a new announcement in MongoDB
    const announcement = new Announcement({ title, content, department });
    await announcement.save();
    
    res.status(201).json({
      message: "Announcement created successfully!",
      data: { 
        id: announcement._id,
        title: announcement.title,
        content: announcement.content,
        department: announcement.department
      },
      status: "success"
    });
  } catch (error) {
    res.status(500).json({
      message: "Error creating announcement: " + error.message,
      status: "error"
    });
  }
});

// Get all announcements
app.get("/api/announcements", async (req, res) => {
  try {
    const announcements = await Announcement.find({});
    res.json({
      message: "Announcements retrieved successfully!",
      data: announcements,
      count: announcements.length,
      status: "success"
    });
  } catch (error) {
    res.status(500).json({
      message: "Error retrieving announcements: " + error.message,
      status: "error"
    });
  }
});

// Get a specific announcement by ID
app.get("/api/announcements/:id", async (req, res) => {
  try {
    const announcement = await Announcement.findById(req.params.id);
    
    if (!announcement) {
      return res.status(404).json({
        message: "Announcement not found",
        status: "error"
      });
    }
    
    res.json({
      message: "Announcement retrieved successfully!",
      data: announcement,
      status: "success"
    });
  } catch (error) {
    res.status(500).json({
      message: "Error retrieving announcement: " + error.message,
      status: "error"
    });
  }
});

// Update an announcement by ID
app.put("/api/announcements/:id", async (req, res) => {
  try {
    const { title, content, department } = req.body;
    
    const announcement = await Announcement.findByIdAndUpdate(
      req.params.id,
      { title, content, department },
      { new: true, runValidators: true }
    );
    
    if (!announcement) {
      return res.status(404).json({
        message: "Announcement not found",
        status: "error"
      });
    }
    
    res.json({
      message: "Announcement updated successfully!",
      data: announcement,
      status: "success"
    });
  } catch (error) {
    res.status(500).json({
      message: "Error updating announcement: " + error.message,
      status: "error"
    });
  }
});

// Delete an announcement by ID
app.delete("/api/announcements/:id", async (req, res) => {
  try {
    const announcement = await Announcement.findByIdAndDelete(req.params.id);
    
    if (!announcement) {
      return res.status(404).json({
        message: "Announcement not found",
        status: "error"
      });
    }
    
    res.json({
      message: "Announcement deleted successfully!",
      data: announcement,
      status: "success"
    });
  } catch (error) {
    res.status(500).json({
      message: "Error deleting announcement: " + error.message,
      status: "error"
    });
  }
});

// Exam management endpoints
// Create a new exam
app.post("/api/exams", async (req, res) => {
  try {
    const { name, date, course } = req.body;
    
    // Create a new exam in MongoDB
    const exam = new Exam({ name, date, course });
    await exam.save();
    
    res.status(201).json({
      message: "Exam created successfully!",
      data: { 
        id: exam._id,
        name: exam.name,
        date: exam.date,
        course: exam.course
      },
      status: "success"
    });
  } catch (error) {
    res.status(500).json({
      message: "Error creating exam: " + error.message,
      status: "error"
    });
  }
});

// Get all exams
app.get("/api/exams", async (req, res) => {
  try {
    const exams = await Exam.find({});
    res.json({
      message: "Exams retrieved successfully!",
      data: exams,
      count: exams.length,
      status: "success"
    });
  } catch (error) {
    res.status(500).json({
      message: "Error retrieving exams: " + error.message,
      status: "error"
    });
  }
});

// Get a specific exam by ID
app.get("/api/exams/:id", async (req, res) => {
  try {
    const exam = await Exam.findById(req.params.id);
    
    if (!exam) {
      return res.status(404).json({
        message: "Exam not found",
        status: "error"
      });
    }
    
    res.json({
      message: "Exam retrieved successfully!",
      data: exam,
      status: "success"
    });
  } catch (error) {
    res.status(500).json({
      message: "Error retrieving exam: " + error.message,
      status: "error"
    });
  }
});

// Update an exam by ID
app.put("/api/exams/:id", async (req, res) => {
  try {
    const { name, date, course } = req.body;
    
    const exam = await Exam.findByIdAndUpdate(
      req.params.id,
      { name, date, course },
      { new: true, runValidators: true }
    );
    
    if (!exam) {
      return res.status(404).json({
        message: "Exam not found",
        status: "error"
      });
    }
    
    res.json({
      message: "Exam updated successfully!",
      data: exam,
      status: "success"
    });
  } catch (error) {
    res.status(500).json({
      message: "Error updating exam: " + error.message,
      status: "error"
    });
  }
});

// Delete an exam by ID
app.delete("/api/exams/:id", async (req, res) => {
  try {
    const exam = await Exam.findByIdAndDelete(req.params.id);
    
    if (!exam) {
      return res.status(404).json({
        message: "Exam not found",
        status: "error"
      });
    }
    
    res.json({
      message: "Exam deleted successfully!",
      data: exam,
      status: "success"
    });
  } catch (error) {
    res.status(500).json({
      message: "Error deleting exam: " + error.message,
      status: "error"
    });
  }
});

// Question management endpoints
// Create a new question
app.post("/api/questions", async (req, res) => {
  try {
    const { text, exam } = req.body;
    
    // Create a new question in MongoDB
    const question = new Question({ text, exam });
    await question.save();
    
    res.status(201).json({
      message: "Question created successfully!",
      data: { 
        id: question._id,
        text: question.text,
        exam: question.exam
      },
      status: "success"
    });
  } catch (error) {
    res.status(500).json({
      message: "Error creating question: " + error.message,
      status: "error"
    });
  }
});

// Get all questions
app.get("/api/questions", async (req, res) => {
  try {
    const questions = await Question.find({});
    res.json({
      message: "Questions retrieved successfully!",
      data: questions,
      count: questions.length,
      status: "success"
    });
  } catch (error) {
    res.status(500).json({
      message: "Error retrieving questions: " + error.message,
      status: "error"
    });
  }
});

// Get a specific question by ID
app.get("/api/questions/:id", async (req, res) => {
  try {
    const question = await Question.findById(req.params.id);
    
    if (!question) {
      return res.status(404).json({
        message: "Question not found",
        status: "error"
      });
    }
    
    res.json({
      message: "Question retrieved successfully!",
      data: question,
      status: "success"
    });
  } catch (error) {
    res.status(500).json({
      message: "Error retrieving question: " + error.message,
      status: "error"
    });
  }
});

// Update a question by ID
app.put("/api/questions/:id", async (req, res) => {
  try {
    const { text, exam } = req.body;
    
    const question = await Question.findByIdAndUpdate(
      req.params.id,
      { text, exam },
      { new: true, runValidators: true }
    );
    
    if (!question) {
      return res.status(404).json({
        message: "Question not found",
        status: "error"
      });
    }
    
    res.json({
      message: "Question updated successfully!",
      data: question,
      status: "success"
    });
  } catch (error) {
    res.status(500).json({
      message: "Error updating question: " + error.message,
      status: "error"
    });
  }
});

// Delete a question by ID
app.delete("/api/questions/:id", async (req, res) => {
  try {
    const question = await Question.findByIdAndDelete(req.params.id);
    
    if (!question) {
      return res.status(404).json({
        message: "Question not found",
        status: "error"
      });
    }
    
    res.json({
      message: "Question deleted successfully!",
      data: question,
      status: "success"
    });
  } catch (error) {
    res.status(500).json({
      message: "Error deleting question: " + error.message,
      status: "error"
    });
  }
});

// Assignment management endpoints

// Create a new assignment with file upload
app.post('/api/assignments', assignmentUpload.single('assignmentFile'), async (req, res) => {
  try {
    const { class: classId, teacher } = req.body;
    
    // Create a new assignment in MongoDB
    const assignment = new Assignment({ class: classId, teacher, filename: req.file.filename, path: req.file.path });
    await assignment.save();
    res.status(201).json({
      message: "Assignment created successfully!",
      data: { 
        id: assignment._id,
        class: assignment.class,
        teacher: assignment.teacher,
        filename: assignment.filename,
        path: assignment.path
      },
      status: "success"
    });
  } catch (error) {
    res.status(500).json({
      message: "Error creating assignment: " + error.message,
      status: "error"
    });
  }
});

// Get all assignments
app.get('/api/assignments', async (req, res) => {
  try {
    const assignments = await Assignment.find({});
    res.json({
      message: "Assignments retrieved successfully!",
      data: assignments,
      count: assignments.length,
      status: "success"
    });
  } catch (error) {
    res.status(500).json({
      message: "Error retrieving assignments: " + error.message,
      status: "error"
    });
  }
});

// Get a specific assignment by ID
app.get('/api/assignments/:id', async (req, res) => {
  try {
    const assignment = await Assignment.findById(req.params.id);
    
    if (!assignment) {
      return res.status(404).json({
        message: "Assignment not found",
        status: "error"
      });
    }
    
    res.json({
      message: "Assignment retrieved successfully!",
      data: assignment,
      status: "success"
    });
  } catch (error) {
    res.status(500).json({
      message: "Error retrieving assignment: " + error.message,
      status: "error"
    });
  }
});

// Update an assignment by ID
app.put('/api/assignments/:id', async (req, res) => {
  try {
    const { class: classId, teacher, filename, path } = req.body;
    
    // Create a new department head in MongoDB
    const departmentHead = new DepartmentHead({ name, email, phoneNo, password, department });
    await departmentHead.save();
    
    res.status(201).json({
      message: "Department head created successfully!",
      data: { 
        id: departmentHead._id,
        name: departmentHead.name,
        email: departmentHead.email,
        phoneNo: departmentHead.phoneNo,
        department: departmentHead.department
      },
      status: "success"
    });
  } catch (error) {
    if (error.code === 11000) {
      // Duplicate email error
      return res.status(400).json({
        message: "Department head with this email already exists",
        status: "error"
      });
    }
    
    res.status(500).json({
      message: "Error creating department head: " + error.message,
      status: "error"
    });
  }
});

// Get all department heads
app.get("/api/department-heads", async (req, res) => {
  try {
    const departmentHeads = await DepartmentHead.find({}).populate('department', 'name science');
    res.json({
      message: "Department heads retrieved successfully!",
      data: departmentHeads,
      count: departmentHeads.length,
      status: "success"
    });
  } catch (error) {
    res.status(500).json({
      message: "Error retrieving department heads: " + error.message,
      status: "error"
    });
  }
});

// Get a specific department head by ID
app.get("/api/department-heads/:id", async (req, res) => {
  try {
    const departmentHead = await DepartmentHead.findById(req.params.id).populate('department', 'name science');
    
    if (!departmentHead) {
      return res.status(404).json({
        message: "Department head not found",
        status: "error"
      });
    }
    
    res.json({
      message: "Department head retrieved successfully!",
      data: departmentHead,
      status: "success"
    });
  } catch (error) {
    res.status(500).json({
      message: "Error retrieving department head: " + error.message,
      status: "error"
    });
  }
});

// Update a department head by ID
app.put("/api/department-heads/:id", async (req, res) => {
  try {
    const { name, email, phoneNo, password, department } = req.body;
    
    const departmentHead = await DepartmentHead.findByIdAndUpdate(
      req.params.id,
      { name, email, phoneNo, password, department },
      { new: true, runValidators: true }
    ).populate('department', 'name science');
    
    if (!departmentHead) {
      return res.status(404).json({
        message: "Department head not found",
        status: "error"
      });
    }
    
    res.json({
      message: "Department head updated successfully!",
      data: departmentHead,
      status: "success"
    });
  } catch (error) {
    if (error.code === 11000) {
      // Duplicate email error
      return res.status(400).json({
        message: "Department head with this email already exists",
        status: "error"
      });
    }
    
    res.status(500).json({
      message: "Error updating department head: " + error.message,
      status: "error"
    });
  }
});

// Delete a department head by ID
app.delete("/api/department-heads/:id", async (req, res) => {
  try {
    const departmentHead = await DepartmentHead.findByIdAndDelete(req.params.id);
    
    if (!departmentHead) {
      return res.status(404).json({
        message: "Department head not found",
        status: "error"
      });
    }
    
    res.json({
      message: "Department head deleted successfully!",
      data: departmentHead,
      status: "success"
    });
  } catch (error) {
    res.status(500).json({
      message: "Error deleting department head: " + error.message,
      status: "error"
    });
  }
});

// Department Head login endpoint

// Verify token endpoint
app.get('/api/auth/verify-token', authenticateToken, async (req, res) => {
  try {
    const user = req.user;
    
    // Find user in database based on role
    let userData;
    if (user.role === 'admin') {
      userData = await Admin.findById(user.id).select('-password');
    } else if (user.role === 'department-head') {
      userData = await DepartmentHead.findById(user.id)
        .select('-password')
        .populate('department', 'name science');
    }

    if (!userData) {
      return res.status(404).json({
        message: 'User not found',
        status: 'error'
      });
    }

    // Add role to user data
    const userWithRole = {
      ...userData._doc,
      type: user.role
    };

    res.json({
      message: 'Token is valid',
      data: userWithRole,
      status: 'success'
    });
  } catch (error) {
    console.error('Error in verify-token:', error);
    res.status(500).json({
      message: 'Error verifying token',
      status: 'error'
    });
  }
});

// Teacher login endpoint
app.post("/api/teachers/login", async (req, res) => {
  try {
    const { email, password } = req.body;
    
    // Find teacher by email
    const teacher = await Teacher.findOne({ email });
    
    if (!teacher) {
      return res.status(401).json({
        message: "Invalid credentials",
        status: "error"
      });
    }
    
    // Check password
    const isPasswordValid = await teacher.comparePassword(password);
    
    if (!isPasswordValid) {
      return res.status(401).json({
        message: "Invalid credentials",
        status: "error"
      });
    }
    
    // Create token
    const token = jwt.sign(
      { 
        id: teacher._id, 
        email: teacher.email,
        role: 'teacher' 
      },
      JWT_SECRET,
      { expiresIn: '1d' }
    );
    
    // Return user data (excluding password)
    const teacherData = teacher.toObject();
    delete teacherData.password;
    
    res.json({
      message: "Login successful",
      status: "success",
      token,
      data: teacherData
    });
  } catch (error) {
    console.error("Teacher login error:", error);
    res.status(500).json({
      message: "An error occurred during login",
      status: "error"
    });
  }
});

app.post("/api/department-heads/login", async (req, res) => {
  try {
    const { email, password } = req.body;
    
    // Find department head by email
    const departmentHead = await DepartmentHead.findOne({ email }).populate('department', 'name science');
    
    if (!departmentHead) {
      return res.status(401).json({
        message: "Invalid credentials",
        status: "error"
      });
    }
    
    // Check password
    const isPasswordValid = await departmentHead.comparePassword(password);
    
    if (!isPasswordValid) {
      return res.status(401).json({
        message: "Invalid credentials",
        status: "error"
      });
    }
    
    // Create token
    const token = jwt.sign(
      { 
        id: departmentHead._id, 
        email: departmentHead.email,
        role: 'department-head' 
      },
      JWT_SECRET,
      { expiresIn: '1d' }
    );
    
    res.json({
      message: "Login successful!",
      token: token,
      data: {
        id: departmentHead._id,
        name: departmentHead.name,
        email: departmentHead.email,
        phoneNo: departmentHead.phoneNo,
        department: departmentHead.department,
        role: 'department-head'
      },
      status: "success"
    });
  } catch (error) {
    res.status(500).json({
      message: "Error during login: " + error.message,
      status: "error"
    });
  }
});

// Class management endpoints
// Create a new class
app.post("/api/classes", async (req, res) => {
  try {
    const { department, year, semester } = req.body;
    
    // Create a new class in MongoDB
    const newClass = new Class({ department, year, semester });
    await newClass.save();
    
    res.status(201).json({
      message: "Class created successfully!",
      data: { 
        id: newClass._id,
        department: newClass.department,
        year: newClass.year,
        semester: newClass.semester
      },
      status: "success"
    });
  } catch (error) {
    if (error.code === 11000) {
      // Duplicate class error (same department, year, semester combination)
      return res.status(400).json({
        message: "A class with this department, year, and semester combination already exists",
        status: "error"
      });
    }
    
    res.status(500).json({
      message: "Error creating class: " + error.message,
      status: "error"
    });
  }
});

// Get all classes or filter by department
app.get("/api/classes", async (req, res) => {
  const { department } = req.query;
  
  try {
    let query = {};
    if (department) {
      query.department = department;
    }
    
    const classes = await Class.find(query).populate('department', 'name science');
    res.json({
      message: "Classes retrieved successfully!",
      data: classes,
      count: classes.length,
      status: "success"
    });
  } catch (error) {
    console.error("Error fetching classes:", error);
    res.status(500).json({
      message: "Error fetching classes",
      error: error.message,
      status: "error"
    });
  }
});

// Get all classes (kept for backward compatibility)
app.get("/api/classes/all", async (req, res) => {
  try {
    const classes = await Class.find({}).populate('department', 'name science');
    res.json({
      message: "Classes retrieved successfully!",
      data: classes,
      count: classes.length,
      status: "success"
    });
  } catch (error) {
    res.status(500).json({
      message: "Error retrieving classes: " + error.message,
      status: "error"
    });
  }
});

// Get a specific class by ID
app.get("/api/classes/:id", async (req, res) => {
  try {
    const classItem = await Class.findById(req.params.id).populate('department', 'name science');
    
    if (!classItem) {
      return res.status(404).json({
        message: "Class not found",
        status: "error"
      });
    }
    
    res.json({
      message: "Class retrieved successfully!",
      data: classItem,
      status: "success"
    });
  } catch (error) {
    res.status(500).json({
      message: "Error retrieving class: " + error.message,
      status: "error"
    });
  }
});

// Update a class by ID
app.put("/api/classes/:id", async (req, res) => {
  try {
    const { department, year, semester } = req.body;
    
    const classItem = await Class.findByIdAndUpdate(
      req.params.id,
      { department, year, semester },
      { new: true, runValidators: true }
    ).populate('department', 'name science');
    
    if (!classItem) {
      return res.status(404).json({
        message: "Class not found",
        status: "error"
      });
    }
    
    res.json({
      message: "Class updated successfully!",
      data: classItem,
      status: "success"
    });
  } catch (error) {
    if (error.code === 11000) {
      // Duplicate class error (same department, year, semester combination)
      return res.status(400).json({
        message: "A class with this department, year, and semester combination already exists",
        status: "error"
      });
    }
    
    res.status(500).json({
      message: "Error updating class: " + error.message,
      status: "error"
    });
  }
});

// Delete a class by ID
app.delete("/api/classes/:id", async (req, res) => {
  try {
    const classItem = await Class.findByIdAndDelete(req.params.id);
    
    if (!classItem) {
      return res.status(404).json({
        message: "Class not found",
        status: "error"
      });
    }
    
    res.json({
      message: "Class deleted successfully!",
      data: classItem,
      status: "success"
    });
  } catch (error) {
    res.status(500).json({
      message: "Error deleting class: " + error.message,
      status: "error"
    });
  }
});

// Teacher management endpoints
// Bulk upload teachers from CSV
app.post("/api/teachers/bulk-upload", upload.single('file'), async (req, res) => {
  console.log('Bulk upload teachers request received');
  console.log('Request file:', req.file);
  
  try {
    if (!req.file) {
      console.error('No file uploaded');
      return res.status(400).json({ message: 'No file uploaded', status: 'error' });
    }

    // Use csv-parser to parse the CSV data
    const resultsFromCsv = [];
    
    // Create a promise to handle the async parsing
    await new Promise((resolve, reject) => {
      const stream = Readable.from(req.file.buffer.toString());
      stream
        .pipe(csv())
        .on('data', (data) => {
          console.log('CSV row data:', data);
          resultsFromCsv.push(data);
        })
        .on('end', resolve)
        .on('error', reject);
    });

    console.log('CSV parsing completed. Rows:', resultsFromCsv.length);
    
    const results = [];
    const errors = [];
    let addedCount = 0;

    // Process each row
    for (let i = 0; i < resultsFromCsv.length; i++) {
      const teacherData = resultsFromCsv[i];
      console.log(`Processing row ${i + 1}:`, teacherData);

      try {
        // Validate required fields
        const requiredFields = ['name', 'email', 'phoneNumber', 'userId', 'password'];
        const missingFields = requiredFields.filter(field => !teacherData[field] || teacherData[field].trim() === '');
        
        if (missingFields.length > 0) {
          throw new Error(`Missing required fields: ${missingFields.join(', ')}`);
        }

        // Clean the data
        const cleanedData = {
          name: teacherData.name.trim(),
          email: teacherData.email.trim().toLowerCase(),
          phoneNumber: teacherData.phoneNumber.trim(),
          userId: teacherData.userId.trim(),
          password: teacherData.password.trim()
        };

        // Check if teacher with same email or userId already exists
        const existingTeacher = await Teacher.findOne({
          $or: [
            { email: cleanedData.email },
            { userId: cleanedData.userId }
          ]
        });

        if (existingTeacher) {
          throw new Error(`Teacher with email ${cleanedData.email} or ID ${cleanedData.userId} already exists`);
        }

        // Create new teacher (password will be hashed by pre-save hook)
        const newTeacher = new Teacher(cleanedData);
        
        console.log('Attempting to save teacher:', newTeacher);

        await newTeacher.save();
        console.log('Teacher saved successfully:', newTeacher._id);
        addedCount++;
        results.push({
          userId: cleanedData.userId,
          email: cleanedData.email,
          status: 'success'
        });
      } catch (error) {
        console.error('Error processing teacher:', error);
        errors.push({
          row: i + 1,
          userId: teacherData.userId,
          email: teacherData.email,
          error: error.message
        });
      }
    }

    console.log('Bulk upload completed. Added:', addedCount, 'Errors:', errors.length);
    res.status(200).json({
      message: `Successfully processed ${resultsFromCsv.length} records`,
      addedCount,
      errorCount: errors.length,
      errors,
      status: 'success'
    });
  } catch (error) {
    console.error('Bulk upload error:', error);
    res.status(500).json({
      message: error.message || 'Error processing bulk upload',
      status: 'error'
    });
  }
});

// Create a new teacher
app.post("/api/teachers", async (req, res) => {
  try {
    const { userId, name, email, phoneNumber, password } = req.body;
    
    // Create a new teacher in MongoDB (password will be hashed by pre-save hook)
    const teacher = new Teacher({ userId, name, email, phoneNumber, password });
    await teacher.save();
    
    res.status(201).json({
      message: "Teacher created successfully!",
      data: { 
        id: teacher._id,
        userId: teacher.userId,
        name: teacher.name,
        email: teacher.email,
        phoneNumber: teacher.phoneNumber
      },
      status: "success"
    });
  } catch (error) {
    if (error.code === 11000) {
      // Duplicate email or userId error
      return res.status(400).json({
        message: "Teacher with this email or user ID already exists",
        status: "error"
      });
    }
    
    res.status(500).json({
      message: "Error creating teacher: " + error.message,
      status: "error"
    });
  }
});

// Test endpoint to check if teacher creation is working
app.post("/api/teachers/test-create", async (req, res) => {
  try {
    console.log('Test teacher creation request received');
    const { userId, name, email, phoneNumber, password } = req.body;
    console.log('Teacher data:', { userId, name, email, phoneNumber, password });
    
    // Create a new teacher in MongoDB (password will be hashed by pre-save hook)
    const teacher = new Teacher({ userId, name, email, phoneNumber, password });
    console.log('Teacher object created:', teacher);
    
    await teacher.save();
    console.log('Teacher saved successfully');
    
    res.status(201).json({
      message: "Test teacher created successfully!",
      data: { 
        id: teacher._id,
        userId: teacher.userId,
        name: teacher.name,
        email: teacher.email,
        phoneNumber: teacher.phoneNumber
      },
      status: "success"
    });
  } catch (error) {
    console.error('Error creating test teacher:', error);
    res.status(500).json({
      message: "Error creating test teacher: " + error.message,
      status: "error"
    });
  }
});

// Get all teachers
app.get("/api/teachers", async (req, res) => {
  try {
    const teachers = await Teacher.find({});
    res.json({
      message: "Teachers retrieved successfully!",
      data: teachers,
      count: teachers.length,
      status: "success"
    });
  } catch (error) {
    res.status(500).json({
      message: "Error retrieving teachers: " + error.message,
      status: "error"
    });
  }
});

// Get a specific teacher by ID
app.get("/api/teachers/:id", async (req, res) => {
  try {
    const teacher = await Teacher.findById(req.params.id);
    
    if (!teacher) {
      return res.status(404).json({
        message: "Teacher not found",
        status: "error"
      });
    }
    
    res.json({
      message: "Teacher retrieved successfully!",
      data: teacher,
      status: "success"
    });
  } catch (error) {
    res.status(500).json({
      message: "Error retrieving teacher: " + error.message,
      status: "error"
    });
  }
});

// Update a teacher by ID
app.put("/api/teachers/:id", async (req, res) => {
  try {
    const { userId, name, email, phoneNumber, password } = req.body;
    
    // Prepare update data
    const updateData = { userId, name, email, phoneNumber };
    
    // Only include password in update if it's provided
    if (password) {
      updateData.password = password; // Will be hashed by pre-save hook
    }
    
    const teacher = await Teacher.findByIdAndUpdate(
      req.params.id,
      updateData,
      { new: true, runValidators: true }
    );
    
    if (!teacher) {
      return res.status(404).json({
        message: "Teacher not found",
        status: "error"
      });
    }
    
    res.json({
      message: "Teacher updated successfully!",
      data: teacher,
      status: "success"
    });
  } catch (error) {
    if (error.code === 11000) {
      // Duplicate email or userId error
      return res.status(400).json({
        message: "Teacher with this email or user ID already exists",
        status: "error"
      });
    }
    
    res.status(500).json({
      message: "Error updating teacher: " + error.message,
      status: "error"
    });
  }
});

// Delete a teacher by ID
app.delete("/api/teachers/:id", async (req, res) => {
  try {
    const teacher = await Teacher.findByIdAndDelete(req.params.id);
    
    if (!teacher) {
      return res.status(404).json({
        message: "Teacher not found",
        status: "error"
      });
    }
    
    res.json({
      message: "Teacher deleted successfully!",
      data: teacher,
      status: "success"
    });
  } catch (error) {
    res.status(500).json({
      message: "Error deleting teacher: " + error.message,
      status: "error"
    });
  }
});

// Get courses for a specific teacher
app.get("/api/teachers/:id/courses", async (req, res) => {
  try {
    const { id } = req.params;
    
    // Find courses where the teacher field matches the teacher ID
    const courses = await Course.find({ teacher: id })
      .populate('department', 'name')
      .populate('class', 'year semester');
      
    // Add student count to each course
    const coursesWithStudentCount = await Promise.all(courses.map(async (course) => {
      // Get the class ID - it might be in course.class._id or course.class depending on population
      const classId = course.class && course.class._id ? course.class._id : course.class;
      
      // Count students in the same class as the course
      const studentCount = await Student.countDocuments({ class: classId });
      
      return {
        ...course.toObject(),
        studentCount
      };
    }));
      
    res.json({
      message: "Courses retrieved successfully!",
      data: coursesWithStudentCount,
      count: coursesWithStudentCount.length,
      status: "success"
    });
  } catch (error) {
    console.error("Error retrieving courses for teacher:", error);
    res.status(500).json({
      message: "Error retrieving courses: " + error.message,
      status: "error"
    });
  }
});

// Course management endpoints
// Create a new course
app.post("/api/courses", async (req, res) => {
  try {
    const { subject, teacher, department, class: classId, code, crh } = req.body;
    
    // Create a new course in MongoDB
    const course = new Course({ subject, teacher, department, class: classId, code, crh });
    await course.save();
    
    res.status(201).json({
      message: "Course created successfully!",
      data: { 
        id: course._id,
        subject: course.subject,
        teacher: course.teacher,
        department: course.department,
        class: course.class,
        code: course.code,
        crh: course.crh
      },
      status: "success"
    });
  } catch (error) {
    if (error.code === 11000) {
      // Duplicate course error (same department, class, and code combination)
      return res.status(400).json({
        message: "A course with this department, class, and code combination already exists",
        status: "error"
      });
    }
    
    res.status(500).json({
      message: "Error creating course: " + error.message,
      status: "error"
    });
  }
});

// Get all courses
app.get("/api/courses", async (req, res) => {
  try {
    const courses = await Course.find({}).populate('teacher', 'name email').populate('department', 'name science').populate('class', 'year semester');
    res.json({
      message: "Courses retrieved successfully!",
      data: courses,
      count: courses.length,
      status: "success"
    });
  } catch (error) {
    res.status(500).json({
      message: "Error retrieving courses: " + error.message,
      status: "error"
    });
  }
});

// Get a specific course by ID
app.get("/api/courses/:id", async (req, res) => {
  try {
    const course = await Course.findById(req.params.id).populate('teacher', 'name email').populate('department', 'name science').populate('class', 'year semester');
    
    if (!course) {
      return res.status(404).json({
        message: "Course not found",
        status: "error"
      });
    }
    
    res.json({
      message: "Course retrieved successfully!",
      data: course,
      status: "success"
    });
  } catch (error) {
    res.status(500).json({
      message: "Error retrieving course: " + error.message,
      status: "error"
    });
  }
});

// Update a course by ID
app.put("/api/courses/:id", async (req, res) => {
  try {
    const { subject, teacher, department, class: classId, code, crh } = req.body;
    
    const course = await Course.findByIdAndUpdate(
      req.params.id,
      { subject, teacher, department, class: classId, code, crh },
      { new: true, runValidators: true }
    ).populate('teacher', 'name email').populate('department', 'name science').populate('class', 'year semester');
    
    if (!course) {
      return res.status(404).json({
        message: "Course not found",
        status: "error"
      });
    }
    
    res.json({
      message: "Course updated successfully!",
      data: course,
      status: "success"
    });
  } catch (error) {
    if (error.code === 11000) {
      // Duplicate course error (same department, class, and code combination)
      return res.status(400).json({
        message: "A course with this department, class, and code combination already exists",
        status: "error"
      });
    }
    
    res.status(500).json({
      message: "Error updating course: " + error.message,
      status: "error"
    });
  }
});

// Delete a course by ID
app.delete("/api/courses/:id", async (req, res) => {
  try {
    const course = await Course.findByIdAndDelete(req.params.id);
    
    if (!course) {
      return res.status(404).json({
        message: "Course not found",
        status: "error"
      });
    }
    
    res.json({
      message: "Course deleted successfully!",
      data: course,
      status: "success"
    });
  } catch (error) {
    res.status(500).json({
      message: "Error deleting course: " + error.message,
      status: "error"
    });
  }
});
// Bulk upload students from CSV
app.post("/api/students/bulk-upload", upload.single('file'), async (req, res) => {
  console.log('Bulk upload request received');
  console.log('Request body:', req.body);
  console.log('Request file:', req.file);
  
  try {
    if (!req.file) {
      console.error('No file uploaded');
      return res.status(400).json({ message: 'No file uploaded', status: 'error' });
    }

    // Get departmentId and classId from form data
    const departmentId = req.body.departmentId;
    const classId = req.body.classId;
    
    console.log('Department ID from request:', departmentId);
    console.log('Class ID from request:', classId);
    
    if (!departmentId || !classId) {
      console.error('Missing required parameters');
      return res.status(400).json({ 
        message: 'Both Department ID and Class ID are required', 
        status: 'error' 
      });
    }
    
    // Check if class exists and belongs to the department
    const classExists = await Class.findOne({ _id: classId, department: departmentId });
    if (!classExists) {
      return res.status(400).json({ 
        message: 'Invalid class or class does not belong to the selected department', 
        status: 'error' 
      });
    }

    // Check if department exists
    const department = await Department.findById(departmentId);
    if (!department) {
      return res.status(400).json({ message: 'Invalid department', status: 'error' });
    }

    const results = [];
    const errors = [];
    let addedCount = 0;

    // Process the CSV file
    const buffer = req.file.buffer.toString();
    const lines = buffer.split('\n').filter(line => line.trim() !== '');
    const headers = lines[0].split(',').map(h => h.trim());

    // Validate headers
    const requiredHeaders = ['name', 'email', 'phoneNo', 'userId', 'password'];
    const missingHeaders = requiredHeaders.filter(h => !headers.includes(h));
    
    if (missingHeaders.length > 0) {
      return res.status(400).json({
        message: `Missing required CSV headers: ${missingHeaders.join(', ')}`,
        status: 'error'
      });
    }

    // Process each line
    for (let i = 1; i < lines.length; i++) {
      const line = lines[i];
      const values = line.split(',');
      const studentData = {};

      // Map headers to values
      headers.forEach((header, index) => {
        if (values[index]) {
          studentData[header] = values[index].trim();
        }
      });

      try {
        // Check if student with same email or userId already exists
        const existingStudent = await Student.findOne({
          $or: [
            { email: studentData.email },
            { userId: studentData.userId }
          ]
        });

        if (existingStudent) {
          throw new Error(`Student with email ${studentData.email} or ID ${studentData.userId} already exists`);
        }

        // Hash password
        const hashedPassword = await bcrypt.hash(studentData.password, 10);

        // Create new student
        const newStudent = new Student({
          name: studentData.name,
          email: studentData.email,
          phoneNo: studentData.phoneNo,
          userId: studentData.userId,
          password: hashedPassword,
          department: departmentId,
          class: classId // Use the classId from the form data
        });

        await newStudent.save();
        addedCount++;
        results.push({
          userId: studentData.userId,
          email: studentData.email,
          status: 'success'
        });
      } catch (error) {
        errors.push({
          line: i + 1,
          userId: studentData.userId,
          email: studentData.email,
          error: error.message
        });
      }
    }

    res.status(200).json({
      message: `Successfully processed ${lines.length - 1} records`,
      addedCount,
      errorCount: errors.length,
      errors,
      status: 'success'
    });
  } catch (error) {
    console.error('Bulk upload error:', error);
    res.status(500).json({
      message: error.message || 'Error processing bulk upload',
      status: 'error'
    });
  }
});

// Create a new student
app.post("/api/students", async (req, res) => {
  try {
    console.log('Raw request body:', req.body);
    console.log('Request headers:', req.headers);
    
    // Ensure we're parsing JSON if content-type is application/json
    if (req.headers['content-type'] === 'application/json') {
      req.body = typeof req.body === 'string' ? JSON.parse(req.body) : req.body;
    }
    
    console.log('Parsed student data:', JSON.stringify(req.body, null, 2));
    
    // Extract fields with null checks and defaults
    const name = req.body.name ? String(req.body.name).trim() : '';
    const userId = req.body.userId ? String(req.body.userId).trim() : '';
    const department = req.body.department ? String(req.body.department).trim() : '';
    const classId = req.body.class ? String(req.body.class).trim() : (req.body.classId ? String(req.body.classId).trim() : '');
    const email = req.body.email ? String(req.body.email).trim().toLowerCase() : '';
    const password = req.body.password || '';
    const phoneNo = req.body.phoneNo ? String(req.body.phoneNo).trim() : '';
    
    // Validate required fields
    const requiredFields = { name, userId, department, class: classId, email, password, phoneNo };
    const missingFields = Object.entries(requiredFields)
      .filter(([_, value]) => !value)
      .map(([key]) => key);
      
    if (missingFields.length > 0) {
      const errorMsg = `Missing required fields: ${missingFields.join(', ')}`;
      console.error('Validation error:', errorMsg);
      return res.status(400).json({
        message: errorMsg,
        status: "error"
      });
    }
    
    // Check if department exists
    const departmentExists = await mongoose.model('Department').findById(department);
    if (!departmentExists) {
      const errorMsg = `Department with ID ${department} not found`;
      console.error(errorMsg);
      return res.status(400).json({
        message: 'Invalid department',
        status: "error"
      });
    }
    
    // Check if class exists
    const classExists = await mongoose.model('Class').findById(classId);
    if (!classExists) {
      const errorMsg = `Class with ID ${classId} not found`;
      console.error(errorMsg);
      return res.status(400).json({
        message: 'Invalid class',
        status: "error"
      });
    }
    
    // Create a new student in MongoDB
    const studentData = { 
      name: name,
      userId: userId, 
      department: department, 
      class: classId, 
      email: email, 
      password: password,
      phoneNo: phoneNo
    };
    
    console.log('Creating student with data:', JSON.stringify(studentData, null, 2));
    
    // Hash the password before saving
    const salt = await bcrypt.genSalt(10);
    studentData.password = await bcrypt.hash(password, salt);
    
    console.log('Hashed password, creating student...');
    
    const student = new Student({
      name: studentData.name,
      userId: studentData.userId,
      department: studentData.department,
      class: studentData.class,
      email: studentData.email,
      password: studentData.password,
      phoneNo: studentData.phoneNo
    });
    
    console.log('Student object before save:', student);
    
    try {
      await student.save();
      console.log('Student saved successfully');
    } catch (saveError) {
      console.error('Error saving student:', saveError);
      throw saveError;
    }
    
    // Populate the response with department and class details
    const savedStudent = await Student.findById(student._id)
      .populate('department', 'name science')
      .populate('class', 'year semester');
    
    console.log('Student created successfully:', JSON.stringify(savedStudent, null, 2));
    
    res.status(201).json({
      message: "Student created successfully!",
      data: savedStudent,
      status: "success"
    });
  } catch (error) {
    console.error('Error in /api/students:', error);
    
    if (error.code === 11000) {
      // Check which field caused the duplicate key error
      const field = error.message.includes('email') ? 'email' : 'user ID';
      return res.status(400).json({
        message: `A student with this ${field} already exists`,
        status: "error"
      });
    }
    
    res.status(500).json({
      message: "Error creating student: " + error.message,
      status: "error"
    });
  }
});

// Get all students
app.get("/api/students", async (req, res) => {
  try {
    const students = await Student.find({}).populate('department', 'name science').populate('class', 'year semester');
    res.json({
      message: "Students retrieved successfully!",
      data: students,
      count: students.length,
      status: "success"
    });
  } catch (error) {
    res.status(500).json({
      message: "Error retrieving students: " + error.message,
      status: "error"
    });
  }
});

// Get a specific student by ID
app.get("/api/students/:id", async (req, res) => {
  try {
    const student = await Student.findById(req.params.id).populate('department', 'name science').populate('class', 'year semester');
    
    if (!student) {
      return res.status(404).json({
        message: "Student not found",
        status: "error"
      });
    }
    
    res.json({
      message: "Student retrieved successfully!",
      data: student,
      status: "success"
    });
  } catch (error) {
    res.status(500).json({
      message: "Error retrieving student: " + error.message,
      status: "error"
    });
  }
});

// Update a student by ID
app.put("/api/students/:id", async (req, res) => {
  try {
    const { userId, department, class: classId, email, password, phoneNo } = req.body;
    
    const student = await Student.findByIdAndUpdate(
      req.params.id,
      { userId, department, class: classId, email, password, phoneNo },
      { new: true, runValidators: true }
    ).populate('department', 'name science').populate('class', 'year semester');
    
    if (!student) {
      return res.status(404).json({
        message: "Student not found",
        status: "error"
      });
    }
    
    res.json({
      message: "Student updated successfully!",
      data: student,
      status: "success"
    });
  } catch (error) {
    if (error.code === 11000) {
      // Duplicate email or userId error
      return res.status(400).json({
        message: "Student with this email or user ID already exists",
        status: "error"
      });
    }
    
    res.status(500).json({
      message: "Error updating student: " + error.message,
      status: "error"
    });
  }
});

// Delete a student by ID
app.delete("/api/students/:id", async (req, res) => {
  try {
    const student = await Student.findByIdAndDelete(req.params.id);
    
    if (!student) {
      return res.status(404).json({
        message: "Student not found",
        status: "error"
      });
    }
    
    res.json({
      message: "Student deleted successfully!",
      data: student,
      status: "success"
    });
  } catch (error) {
    res.status(500).json({
      message: "Error deleting student: " + error.message,
      status: "error"
    });
  }
});

// Announcement management endpoints
// Create a new announcement
app.post("/api/announcements", async (req, res) => {
  try {
    const { class: classId, teacher, title, message } = req.body;
    
    // Create a new announcement in MongoDB
    const announcement = new Announcement({ class: classId, teacher, title, message });
    await announcement.save();
    
    res.status(201).json({
      message: "Announcement created successfully!",
      data: { 
        id: announcement._id,
        class: announcement.class,
        teacher: announcement.teacher,
        title: announcement.title,
        message: announcement.message,
        createdAt: announcement.createdAt
      },
      status: "success"
    });
  } catch (error) {
    res.status(500).json({
      message: "Error creating announcement: " + error.message,
      status: "error"
    });
  }
});

// Get all announcements
app.get("/api/announcements", async (req, res) => {
  try {
    const announcements = await Announcement.find({}).populate('class', 'year semester').populate('teacher', 'name email');
    res.json({
      message: "Announcements retrieved successfully!",
      data: announcements,
      count: announcements.length,
      status: "success"
    });
  } catch (error) {
    res.status(500).json({
      message: "Error retrieving announcements: " + error.message,
      status: "error"
    });
  }
});

// Get a specific announcement by ID
app.get("/api/announcements/:id", async (req, res) => {
  try {
    const announcement = await Announcement.findById(req.params.id).populate('class', 'year semester').populate('teacher', 'name email');
    
    if (!announcement) {
      return res.status(404).json({
        message: "Announcement not found",
        status: "error"
      });
    }
    
    res.json({
      message: "Announcement retrieved successfully!",
      data: announcement,
      status: "success"
    });
  } catch (error) {
    res.status(500).json({
      message: "Error retrieving announcement: " + error.message,
      status: "error"
    });
  }
});

// Update an announcement by ID
app.put("/api/announcements/:id", async (req, res) => {
  try {
    const { class: classId, teacher, title, message } = req.body;
    
    const announcement = await Announcement.findByIdAndUpdate(
      req.params.id,
      { class: classId, teacher, title, message },
      { new: true, runValidators: true }
    ).populate('class', 'year semester').populate('teacher', 'name email');
    
    if (!announcement) {
      return res.status(404).json({
        message: "Announcement not found",
        status: "error"
      });
    }
    
    res.json({
      message: "Announcement updated successfully!",
      data: announcement,
      status: "success"
    });
  } catch (error) {
    res.status(500).json({
      message: "Error updating announcement: " + error.message,
      status: "error"
    });
  }
});

// Delete an announcement by ID
app.delete("/api/announcements/:id", async (req, res) => {
  try {
    const announcement = await Announcement.findByIdAndDelete(req.params.id);
    
    if (!announcement) {
      return res.status(404).json({
        message: "Announcement not found",
        status: "error"
      });
    }
    
    res.json({
      message: "Announcement deleted successfully!",
      data: announcement,
      status: "success"
    });
  } catch (error) {
    res.status(500).json({
      message: "Error deleting announcement: " + error.message,
      status: "error"
    });
  }
});

// Course management endpoints

// Get all courses with optional filters
app.get('/api/courses', async (req, res) => {
  try {
    const { department, class: classId, teacher } = req.query;
    const query = {};
    
    if (department) query.department = department;
    if (classId) query.class = classId;
    if (teacher) query.teacher = teacher;
    
    // Populate the referenced fields for better frontend display
    const courses = await Course.find(query)
      .populate('teacher', 'name email')
      .populate('department', 'name')
      .populate('class', 'year semester');
      
    res.json({
      message: 'Courses retrieved successfully',
      data: courses,
      status: 'success'
    });
  } catch (error) {
    console.error('Error fetching courses:', error);
    res.status(500).json({
      message: 'Error retrieving courses',
      error: error.message,
      status: 'error'
    });
  }
});

// Create a new course
app.post('/api/courses', async (req, res) => {
  try {
    const { subject, teacher, department, class: classId, code, crh } = req.body;
    
    // Validate required fields
    if (!subject || !teacher || !department || !classId || !code || crh === undefined) {
      return res.status(400).json({
        message: 'All fields are required',
        status: 'error'
      });
    }
    
    // Check if course with same code already exists
    const existingCourse = await Course.findOne({ code });
    if (existingCourse) {
      return res.status(400).json({
        message: 'A course with this code already exists',
        status: 'error'
      });
    }
    
    // Create new course
    const course = new Course({
      subject,
      teacher,
      department,
      class: classId,
      code,
      crh: parseFloat(crh)
    });
    
    await course.save();
    
    // Populate the response with referenced data
    const savedCourse = await Course.findById(course._id)
      .populate('teacher', 'name email')
      .populate('department', 'name')
      .populate('class', 'year semester');
    
    res.status(201).json({
      message: 'Course created successfully',
      data: savedCourse,
      status: 'success'
    });
  } catch (error) {
    console.error('Error creating course:', error);
    res.status(500).json({
      message: 'Error creating course',
      error: error.message,
      status: 'error'
    });
  }
});

// Update a course
app.put('/api/courses/:id', async (req, res) => {
  try {
    const { subject, teacher, department, class: classId, code, crh } = req.body;
    
    // Check if course exists
    const course = await Course.findById(req.params.id);
    if (!course) {
      return res.status(404).json({
        message: 'Course not found',
        status: 'error'
      });
    }
    
    // Check if code is being changed to an existing one
    if (code && code !== course.code) {
      const existingCourse = await Course.findOne({ code });
      if (existingCourse) {
        return res.status(400).json({
          message: 'A course with this code already exists',
          status: 'error'
        });
      }
    }
    
    // Update course fields
    if (subject) course.subject = subject;
    if (teacher) course.teacher = teacher;
    if (department) course.department = department;
    if (classId) course.class = classId;
    if (code) course.code = code;
    if (crh !== undefined) course.crh = parseFloat(crh);
    
    await course.save();
    
    // Populate the response with referenced data
    const updatedCourse = await Course.findById(course._id)
      .populate('teacher', 'name email')
      .populate('department', 'name')
      .populate('class', 'year semester');
    
    res.json({
      message: 'Course updated successfully',
      data: updatedCourse,
      status: 'success'
    });
  } catch (error) {
    console.error('Error updating course:', error);
    res.status(500).json({
      message: 'Error updating course',
      error: error.message,
      status: 'error'
    });
  }
});

// Delete a course
app.delete('/api/courses/:id', async (req, res) => {
  try {
    const course = await Course.findByIdAndDelete(req.params.id);
    
    if (!course) {
      return res.status(404).json({
        message: 'Course not found',
        status: 'error'
      });
    }
    
    res.json({
      message: 'Course deleted successfully',
      status: 'success'
    });
  } catch (error) {
    console.error('Error deleting course:', error);
    res.status(500).json({
      message: 'Error deleting course',
      error: error.message,
      status: 'error'
    });
  }
});

// Assignment management endpoints

// Create a new assignment
app.post('/api/assignments', async (req, res) => {
  try {
    const { class: classId, teacher } = req.body;
    
    // Validate required fields
    if (!classId || !teacher) {
      return res.status(400).json({
        message: 'Class and teacher are required',
        status: 'error'
      });
    }
    
    // Check if file was uploaded
    if (!req.file) {
      return res.status(400).json({
        message: 'Assignment file is required',
        status: 'error'
      });
    }
    
    // Create new assignment
    const assignment = new Assignment({
      class: classId,
      teacher,
      filename: req.file.filename,
      path: req.file.path,
      originalName: req.file.originalname,
      mimeType: req.file.mimetype,
      size: req.file.size
    });
    
    await assignment.save();
    
    // Populate the response with referenced data
    const savedAssignment = await Assignment.findById(assignment._id)
      .populate('class', 'year semester')
      .populate('teacher', 'name email');
    
    res.status(201).json({
      message: 'Assignment created successfully',
      data: savedAssignment,
      status: 'success'
    });
  } catch (error) {
    console.error('Error creating assignment:', error);
    
    if (error.code === 11000) {
      return res.status(400).json({
        message: 'An assignment with this class, teacher, and filename already exists',
        status: 'error'
      });
    }
    
    res.status(500).json({
      message: 'Error creating assignment',
      error: error.message,
      status: 'error'
    });
  }
});

// Get all assignments with optional filters
app.get('/api/assignments', async (req, res) => {
  try {
    const { class: classId, teacher } = req.query;
    const query = {};
    
    if (classId) query.class = classId;
    if (teacher) query.teacher = teacher;
    
    // Populate the referenced fields for better frontend display
    const assignments = await Assignment.find(query)
      .populate('class', 'year semester')
      .populate('teacher', 'name email')
      .sort({ createdAt: -1 });
      
    res.json({
      message: 'Assignments retrieved successfully',
      data: assignments,
      count: assignments.length,
      status: 'success'
    });
  } catch (error) {
    console.error('Error fetching assignments:', error);
    res.status(500).json({
      message: 'Error retrieving assignments',
      error: error.message,
      status: 'error'
    });
  }
});

// Get a specific assignment by ID
app.get('/api/assignments/:id', async (req, res) => {
  try {
    const assignment = await Assignment.findById(req.params.id)
      .populate('class', 'year semester')
      .populate('teacher', 'name email');
    
    if (!assignment) {
      return res.status(404).json({
        message: 'Assignment not found',
        status: 'error'
      });
    }
    
    res.json({
      message: 'Assignment retrieved successfully',
      data: assignment,
      status: 'success'
    });
  } catch (error) {
    console.error('Error retrieving assignment:', error);
    res.status(500).json({
      message: 'Error retrieving assignment',
      error: error.message,
      status: 'error'
    });
  }
});

// Update an assignment by ID (without file upload)
app.put('/api/assignments/:id', async (req, res) => {
  try {
    const { class: classId, teacher } = req.body;
    
    const assignment = await Assignment.findByIdAndUpdate(
      req.params.id,
      { class: classId, teacher },
      { new: true, runValidators: true }
    ).populate('class', 'year semester').populate('teacher', 'name email');
    
    if (!assignment) {
      return res.status(404).json({
        message: 'Assignment not found',
        status: 'error'
      });
    }
    
    res.json({
      message: 'Assignment updated successfully',
      data: assignment,
      status: 'success'
    });
  } catch (error) {
    console.error('Error updating assignment:', error);
    
    if (error.code === 11000) {
      return res.status(400).json({
        message: 'An assignment with this class, teacher, and filename already exists',
        status: 'error'
      });
    }
    
    res.status(500).json({
      message: 'Error updating assignment',
      error: error.message,
      status: 'error'
    });
  }
});

// Delete an assignment by ID
app.delete('/api/assignments/:id', async (req, res) => {
  try {
    const assignment = await Assignment.findByIdAndDelete(req.params.id);
    
    if (!assignment) {
      return res.status(404).json({
        message: 'Assignment not found',
        status: 'error'
      });
    }
    
    // Delete the file from the filesystem
    try {
      if (fs.existsSync(assignment.path)) {
        fs.unlinkSync(assignment.path);
      }
    } catch (fileError) {
      console.error('Error deleting assignment file:', fileError);
    }
    
    res.json({
      message: 'Assignment deleted successfully',
      status: 'success'
    });
  } catch (error) {
    console.error('Error deleting assignment:', error);
    res.status(500).json({
      message: 'Error deleting assignment',
      error: error.message,
      status: 'error'
    });
  }
});

// Download an assignment file
app.get('/api/assignments/:id/download', async (req, res) => {
  try {
    const assignment = await Assignment.findById(req.params.id);
    
    if (!assignment) {
      return res.status(404).json({
        message: 'Assignment not found',
        status: 'error'
      });
    }
    
    // Check if file exists
    if (!fs.existsSync(assignment.path)) {
      return res.status(404).json({
        message: 'Assignment file not found',
        status: 'error'
      });
    }
    
    // Set headers for file download
    res.setHeader('Content-Disposition', `attachment; filename="${assignment.originalName}"`);
    res.setHeader('Content-Type', assignment.mimeType);
    
    // Stream the file
    const fileStream = fs.createReadStream(assignment.path);
    fileStream.pipe(res);
  } catch (error) {
    console.error('Error downloading assignment:', error);
    res.status(500).json({
      message: 'Error downloading assignment',
      error: error.message,
      status: 'error'
    });
  }
});

// Exam management endpoints

// Create a new exam
app.post('/api/exams', async (req, res) => {
  try {
    const { class: classId, teacher, title, duration, startTime } = req.body;
    
    // Validate required fields
    if (!classId || !teacher || !title || !duration || !startTime) {
      return res.status(400).json({
        message: 'All fields are required',
        status: 'error'
      });
    }
    
    // Create new exam
    const exam = new Exam({
      class: classId,
      teacher,
      title,
      duration: parseInt(duration),
      startTime
    });
    
    await exam.save();
    
    // Populate the response with referenced data
    const savedExam = await Exam.findById(exam._id)
      .populate('class', 'year semester')
      .populate('teacher', 'name email');
    
    res.status(201).json({
      message: 'Exam created successfully',
      data: savedExam,
      status: 'success'
    });
  } catch (error) {
    console.error('Error creating exam:', error);
    
    if (error.code === 11000) {
      return res.status(400).json({
        message: 'An exam with this class, teacher, and start time already exists',
        status: 'error'
      });
    }
    
    res.status(500).json({
      message: 'Error creating exam',
      error: error.message,
      status: 'error'
    });
  }
});

// Get all exams with optional filters
app.get('/api/exams', async (req, res) => {
  try {
    const { class: classId, teacher } = req.query;
    const query = {};
    
    if (classId) query.class = classId;
    if (teacher) query.teacher = teacher;
    
    // Populate the referenced fields for better frontend display
    const exams = await Exam.find(query)
      .populate('class', 'year semester')
      .populate('teacher', 'name email')
      .sort({ startTime: 1 });
      
    res.json({
      message: 'Exams retrieved successfully',
      data: exams,
      count: exams.length,
      status: 'success'
    });
  } catch (error) {
    console.error('Error fetching exams:', error);
    res.status(500).json({
      message: 'Error retrieving exams',
      error: error.message,
      status: 'error'
    });
  }
});

// Get a specific exam by ID
app.get('/api/exams/:id', async (req, res) => {
  try {
    const exam = await Exam.findById(req.params.id)
      .populate('class', 'year semester')
      .populate('teacher', 'name email');
    
    if (!exam) {
      return res.status(404).json({
        message: 'Exam not found',
        status: 'error'
      });
    }
    
    res.json({
      message: 'Exam retrieved successfully',
      data: exam,
      status: 'success'
    });
  } catch (error) {
    console.error('Error retrieving exam:', error);
    res.status(500).json({
      message: 'Error retrieving exam',
      error: error.message,
      status: 'error'
    });
  }
});

// Update an exam by ID
app.put('/api/exams/:id', async (req, res) => {
  try {
    const { class: classId, teacher, title, duration, startTime } = req.body;
    
    const exam = await Exam.findByIdAndUpdate(
      req.params.id,
      { class: classId, teacher, title, duration, startTime },
      { new: true, runValidators: true }
    ).populate('class', 'year semester').populate('teacher', 'name email');
    
    if (!exam) {
      return res.status(404).json({
        message: 'Exam not found',
        status: 'error'
      });
    }
    
    res.json({
      message: 'Exam updated successfully',
      data: exam,
      status: 'success'
    });
  } catch (error) {
    console.error('Error updating exam:', error);
    
    if (error.code === 11000) {
      return res.status(400).json({
        message: 'An exam with this class, teacher, and start time already exists',
        status: 'error'
      });
    }
    
    res.status(500).json({
      message: 'Error updating exam',
      error: error.message,
      status: 'error'
    });
  }
});

// Delete an exam by ID
app.delete('/api/exams/:id', async (req, res) => {
  try {
    const exam = await Exam.findByIdAndDelete(req.params.id);
    
    if (!exam) {
      return res.status(404).json({
        message: 'Exam not found',
        status: 'error'
      });
    }
    
    res.json({
      message: 'Exam deleted successfully',
      status: 'success'
    });
  } catch (error) {
    console.error('Error deleting exam:', error);
    res.status(500).json({
      message: 'Error deleting exam',
      error: error.message,
      status: 'error'
    });
  }
});

// Question management endpoints

// Create a new question
app.post('/api/questions', async (req, res) => {
  try {
    const { exam, questionText, optionA, optionB, optionC, optionD, correctOption } = req.body;
    
    // Validate required fields
    if (!exam || !questionText || !optionA || !optionB || !optionC || !optionD || !correctOption) {
      return res.status(400).json({
        message: 'All fields are required',
        status: 'error'
      });
    }
    
    // Validate correctOption is one of A, B, C, D
    if (!['A', 'B', 'C', 'D'].includes(correctOption)) {
      return res.status(400).json({
        message: 'Correct option must be one of A, B, C, or D',
        status: 'error'
      });
    }
    
    // Create new question
    const question = new Question({
      exam,
      questionText,
      optionA,
      optionB,
      optionC,
      optionD,
      correctOption
    });
    
    await question.save();
    
    // Populate the response with referenced data
    const savedQuestion = await Question.findById(question._id)
      .populate('exam', 'title');
    
    res.status(201).json({
      message: 'Question created successfully',
      data: savedQuestion,
      status: 'success'
    });
  } catch (error) {
    console.error('Error creating question:', error);
    
    if (error.code === 11000) {
      return res.status(400).json({
        message: 'A question with this exam and text already exists',
        status: 'error'
      });
    }
    
    res.status(500).json({
      message: 'Error creating question',
      error: error.message,
      status: 'error'
    });
  }
});

// Get all questions with optional filters
app.get('/api/questions', async (req, res) => {
  try {
    const { exam } = req.query;
    const query = {};
    
    if (exam) query.exam = exam;
    
    // Populate the referenced fields for better frontend display
    const questions = await Question.find(query)
      .populate('exam', 'title');
      
    res.json({
      message: 'Questions retrieved successfully',
      data: questions,
      count: questions.length,
      status: 'success'
    });
  } catch (error) {
    console.error('Error fetching questions:', error);
    res.status(500).json({
      message: 'Error retrieving questions',
      error: error.message,
      status: 'error'
    });
  }
});

// Get a specific question by ID
app.get('/api/questions/:id', async (req, res) => {
  try {
    const question = await Question.findById(req.params.id)
      .populate('exam', 'title');
    
    if (!question) {
      return res.status(404).json({
        message: 'Question not found',
        status: 'error'
      });
    }
    
    res.json({
      message: 'Question retrieved successfully',
      data: question,
      status: 'success'
    });
  } catch (error) {
    console.error('Error retrieving question:', error);
    res.status(500).json({
      message: 'Error retrieving question',
      error: error.message,
      status: 'error'
    });
  }
});

// Update a question by ID
app.put('/api/questions/:id', async (req, res) => {
  try {
    const { exam, questionText, optionA, optionB, optionC, optionD, correctOption } = req.body;
    
    // Validate required fields
    if (!exam || !questionText || !optionA || !optionB || !optionC || !optionD || !correctOption) {
      return res.status(400).json({
        message: 'All fields are required',
        status: 'error'
      });
    }
    
    // Validate correctOption is one of A, B, C, D
    if (!['A', 'B', 'C', 'D'].includes(correctOption)) {
      return res.status(400).json({
        message: 'Correct option must be one of A, B, C, or D',
        status: 'error'
      });
    }
    
    const question = await Question.findByIdAndUpdate(
      req.params.id,
      { exam, questionText, optionA, optionB, optionC, optionD, correctOption },
      { new: true, runValidators: true }
    ).populate('exam', 'title');
    
    if (!question) {
      return res.status(404).json({
        message: 'Question not found',
        status: 'error'
      });
    }
    
    res.json({
      message: 'Question updated successfully',
      data: question,
      status: 'success'
    });
  } catch (error) {
    console.error('Error updating question:', error);
    
    if (error.code === 11000) {
      return res.status(400).json({
        message: 'A question with this exam and text already exists',
        status: 'error'
      });
    }
    
    res.status(500).json({
      message: 'Error updating question',
      error: error.message,
      status: 'error'
    });
  }
});

// Delete a question by ID
app.delete('/api/questions/:id', async (req, res) => {
  try {
    const question = await Question.findByIdAndDelete(req.params.id);
    
    if (!question) {
      return res.status(404).json({
        message: 'Question not found',
        status: 'error'
      });
    }
    
    res.json({
      message: 'Question deleted successfully',
      status: 'success'
    });
  } catch (error) {
    console.error('Error deleting question:', error);
    res.status(500).json({
      message: 'Error deleting question',
      error: error.message,
      status: 'error'
    });
  }
});

    }
    
    res.json({
      message: 'Question retrieved successfully',
      data: question,
      status: 'success'
    });
  } catch (error) {
    console.error('Error retrieving question:', error);
    res.status(500).json({
      message: 'Error retrieving question',
      error: error.message,
      status: 'error'
    });
  }
});

// Update a question by ID
app.put('/api/questions/:id', async (req, res) => {
  try {
    const { exam, questionText, optionA, optionB, optionC, optionD, correctOption } = req.body;
    
    const question = await Question.findByIdAndUpdate(
      req.params.id,
      { exam, questionText, optionA, optionB, optionC, optionD, correctOption },
      { new: true, runValidators: true }
    ).populate('exam', 'title');
    
    if (!question) {
      return res.status(404).json({
        message: 'Question not found',
        status: 'error'
      });
    }
    
    // Validate correctOption is one of A, B, C, D
    if (correctOption && !['A', 'B', 'C', 'D'].includes(correctOption)) {
      return res.status(400).json({
        message: 'Correct option must be one of A, B, C, or D',
        status: 'error'
      });
    }
    
    res.json({
      message: 'Question updated successfully',
      data: question,
      status: 'success'
    });
  } catch (error) {
    console.error('Error updating question:', error);
    
    if (error.code === 11000) {
      return res.status(400).json({
        message: 'A question with this exam and text already exists',
        status: 'error'
      });
    }
    
    res.status(500).json({
      message: 'Error updating question',
      error: error.message,
      status: 'error'
    });
  }
});

// Delete a question by ID
app.delete('/api/questions/:id', async (req, res) => {
  try {
    const question = await Question.findByIdAndDelete(req.params.id);
    
    if (!question) {
      return res.status(404).json({
        message: 'Question not found',
        status: 'error'
      });
    }
    
    res.json({
      message: 'Question deleted successfully',
      status: 'success'
    });
  } catch (error) {
    console.error('Error deleting question:', error);
    res.status(500).json({
      message: 'Error deleting question',
      error: error.message,
      status: 'error'
    });
  }
});

const PORT = process.env.PORT || 5000;
app.listen(PORT, () => console.log(`🚀 Server running on port ${PORT}`));